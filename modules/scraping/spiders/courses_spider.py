"""
CSC111 Final Project: Simplifying the UofT Course Selection Process

Description
===============================
A file to scrape course data from the UofT course search website.
Note that this file is never run during the running of the main file of the program, it was already run to build the
dataset that the program runs.
Additionally, this file is also never run directly to scrape the website data (It will error if run directly).
The scrapy library has a number of shell commands that are used to scrape data. After using scrapy to autogenerate the
file __init__.py in  scraping/spiders, the files __init__.py, items.py, middlewares.py, pipelines.py,
settings.py in data-processing/scraping and the file scraping.cfg in data-processing, the shell command
"scrapy crawl courses -o <filename>.json" can be used to crawl the specified data and save it in the given file

Copyright and Usage Information
===============================
This file is Copyright (c) 2023 Noah Black, Nikita Goncharov and Adam Pralat.
"""

import scrapy

class CoursesSpider(scrapy.Spider):
    name = "courses"

    def start_requests(self):
        """
        Function to scrape specified URLs
        """
        # List of URLs to scrape
        base_url = "https://artsci.calendar.utoronto.ca/search-courses?page="
        urls = [base_url + str(i) for i in range(0, 168)]

        # Go through each URL and scrape the data specified in the function below
        for url in urls:
            yield scrapy.Request(url=url, callback=self.parse)

    def parse(self, response) :
        """
        Parse a single URL from the above list
        Note that each individual course data will be yielded from the function
        The method outline was autogenerated by scrapy
        """
        for n, row in enumerate(response.css("div.views-row")):
            # The way the HTML document is formatted for the website, all information for each course is stored
            # on every other views-row div in the file
            if n % 2 == 0:
                # Note that a number of try/except statements are used in the function below
                # If a course does not have a given attribute, row.css(...attribute...) will return None, which will
                # cause an attribute error. If this happens, the program will set the attribute for that course
                # to be empty/None (Depending on the type of the attribute)

                # Extract the course name and code
                course_name = row.css("h3.js-views-accordion-group-header::text").extract()[0].strip()
                course_code = course_name[0:8]

                # Extract the course hours
                try:
                    hours = row.css("span.views-field.views-field-field-hours").css("span.field-content *::text").extract()[0]
                except (AttributeError, IndexError):
                    hours = None

                # Extract the course description
                try:
                    description_text = row.css("div.views-field.views-field-body").css("div.field-content *::text").extract()
                    description = ''.join(description_text)
                except AttributeError:
                    description = ''

                # Extract the course prerequisites
                try:
                    text = row.css("span.views-field.views-field-field-prerequisite").css("span.field-content *::text").extract()
                    prereqs = process_course_requirements(text, course_code)
                    prereq_text = ''.join(text)
                except AttributeError:
                    prereqs = ''
                    prereq_text = ''

                # Extract the course corequisites
                try:
                    text = row.css("span.views-field.views-field-field-corequisite").css("span.field-content *::text").extract()
                    coreqs = process_course_requirements(text, course_code)
                    coreq_text = ''.join(text)
                except AttributeError:
                    coreqs = ''
                    coreq_text = ''

                # Extract the recommended prep
                try:
                    text = row.css("span.views-field.views-field-field-recommended").css("span.field-content *::text").extract()
                    prep = []
                    for i in text:
                        if is_course_format(i):
                            prep.append(i)
                    prep_text = ''.join(text)
                except AttributeError:
                    prep = []
                    prep_text = ''

                # Extract the distribution requirement
                try:
                    distribution = row.css("span.views-field.views-field-field-distribution-requirements").css("span.field-content *::text").extract()
                except AttributeError:
                    distribution = []

                # Extract the breadth requirement
                try:
                    breadth = row.css("span.views-field.views-field-field-breadth-requirements").css("span.field-content *::text").extract()
                except AttributeError:
                    breadth = []

                # Extract the mode of delivery
                try:
                    mode_of_delivery = row.css("span.views-field.views-field-field-method-of-delivery").css("span.field-content *::text").extract()
                except AttributeError:
                    mode_of_delivery = []

                # Extract the exclusions
                try:
                    text = row.css("span.views-field.views-field-field-exclusion").css("span.field-content *::text").extract()
                    exclusions = process_course_requirements(text, course_code)
                    exclusion_text = ''.join(text)
                except AttributeError:
                    exclusions = ''
                    exclusion_text = ''

                # Yield the data from the current course
                yield {
                    "course name": course_name,
                    "hours": hours,
                    "description": description,
                    "prerequisites": prereqs,
                    "corequisites": coreqs,
                    "prep": prep,
                    "distribution": distribution,
                    "breadth": breadth,
                    "mode of delivery": mode_of_delivery,
                    "exclusions": exclusions,
                    "prereq text": prereq_text,
                    "coreq text": coreq_text,
                    "exclusion text": exclusion_text,
                    "prep text": prep_text,
                    "course code": course_code
                }


def process_course_requirements(requirements: list[str], curr_course: str) -> str:
    """
    Function that takes course requirements as displayed on the website and parses them into a uniform format

    Course requirement format:
    () are used to group requirements together
    Separators:
    - ^ means "and"
    - | means "or"

    Logically, the operator hierarcy is () -> | -> ^

    Note that this does not process every set of requirements fully correct, so more data cleaning is done later on
    Preconditions:
    - Each course is stored in an individual element (HTML document stores courses like this, so this precondition
    will always be fufilled)

    >>> process_course_requirements(['CSC110Y1', ' and ', 'CSC111H1'], 'CSC259Y1') # Note CSC259Y1 is a made up course
    'CSC110Y1^CSC111H1'
    >>> courses = ['ECO200Y1', '/ ', 'ECO204Y1', '/', 'ECO206Y1', '; ', 'ECO220Y1', '/ ', 'ECO227Y1', '/ ', '(',
    >>> 'STA237H1', ',',  'STA238H1', ')/(', 'STA247H1', ',',  'STA248H1', ')/ (',  'STA257H1', ', ', 'STA261H1', ')']
    >>> process_course_requirements(courses, 'ECO338H1')
    'ECO200Y1|ECO204Y1|ECO206Y1^ECO220Y1|ECO227Y1|(STA237H1^STA238H1)|(STA247H1^STA248H1)|(STA257H1^STA261H1)'
    """
    out = ""
    for line in requirements:
        if is_course_format(line) and line != curr_course:
            # Add a requirement if it is a course, excluding the current course
            out += line
        else:
            # Replace separators represented as words/characters with symbols
            line = line.replace('++', '') # Some courses have ++ in requirements, should not be interpreted as "and"
            line = line.replace('+', '^')
            line = line.replace('; and', '^')
            line = line.replace('; or', '|')
            line = line.replace('or higher', '')
            line = line.replace(', and', '^')
            line = line.replace(', or', '|')
            line = line.replace('and/or', '|')
            line = line.replace('and', '^')
            line = line.replace(';', '^')
            line = line.replace(',', '^')
            line = line.replace('/', '|')
            line = line.replace('or', '|')
            for i in line:
                if i in ('|', '^', '(', ')'):
                    out += i
    return out
def is_course_format(s: str) -> bool:
    """
    Helper function - Return whether a string is in the format of a course

    >>> is_course_format("CSC111H1")
    True
    >>> is_course_format("CSCAA1")
    False
    >>> is_course_format("")
    False
    """
    return len(s) == 8 and s[0:3].isalpha() and (s[3:6].isnumeric() or (s[4:6].isnumeric())) and s[6].isalpha() \
           and s[7].isnumeric()

if __name__ == '__main__':
    import python_ta
    import doctest
    doctest.testmod()
    python_ta.check_all(config={
        'extra-imports': ['scrapy'],
        'allowed-io': [],
        'max-line-length': 120
    })
